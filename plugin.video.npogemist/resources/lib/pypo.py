# -*- coding: utf-8 -*-
"""Simplest possible language utility class.

When runs as main, this will create the files strings.py, local_strings.py and
kodi_strings.py, which are used to help localization, but using
the Kodi utility functions. For each localized string, a variable will be created
with a sensible name, which you can use to look up translated strings.

Syntax:
pypo.py [<pot_path>] [<kodi_resource_path>]

where kodi resource path is a directory with standard kodi resources, e.g.
%USERPROFILE%\\AppData\\Local\\Packages\\XBMCFoundation.Kodi_4n2hpmxwrvr6p\\LocalCache\\Roaming\\Kodi\\addons\\resource.language.nl_nl\\resources

If you specify a kodi resource path, kodi_strings.py will be generated
as well for standard strings. You need to do this once.
If you don't specify it, only strings.py and local_strings.py will be generated.

When included as a module, lang.get_string(language.string.resourceid) wil
return a localized string, either from the addon resources, or from
the official Kodi resources (tried in that order.) It will use
kodi_strings and local_strings mentioned above to look up the variable used,
so your IDE can be helpful.

So you can use this class like this:
- Use the following in your plugin:
      po = Po(addon, xbmc)
      s = po.get_string
- Use resources in the form s(pypo.strings.mystring)
- add entries in .po files
- If you add new resources in your strings.po, re-run pypo.py and check the pypo.strings.variables used
"""
import keyword
import string
import sys
import os.path
from codecs import open

# If used as a module, unconditionally require strings to exist.
if __name__ != "__main__":
    import local_strings
    import kodi_strings
    import strings


class Po(object):
    def __init__(self, addon, xbmc):
        """Create a Language object for this addon."""
        self.addon = addon
        self.xbmc = xbmc

    def get_string(self, key):
        """Return the localized string for a key."""
        if key in local_strings.__dict__.values():
            get_localized_string = self.addon.getLocalizedString
        elif key in kodi_strings.__dict__.values():
            get_localized_string = self.xbmc.getLocalizedString
        else:
            # en_gb doesn't have it, error!
            return "<{0}!>".format(key)
        ls = get_localized_string(key)
        if ls is not None:
            return ls
        else:
            # no localization, return <key>
            return "<{0}>".format(key)


if __name__ == "__main__":
    DO_TEST = False
    import re

    DO_NOT_EDIT_WARNING = "# -*- coding: utf-8 -*-\n# This file is automatically generated by pypo.py.\n# Do not edit; your changes will be erased.\n"
    IMPORT_STAR_IS_BAD = "\n# import * is done deliberately here, to insert all symbols into strings.\n# The user of this class shouldn't care from which .po file a string comes.\n"

    def find_nth(haystack, needle, n):
        start = haystack.find(needle)
        while start >= 0 and n > 1:
            start = haystack.find(needle, start+len(needle))
            n -= 1
        return start

    def init_strings(po_path, py_path):
        """Generate a python file with a string dictionary in it.

        po_path is the .po file to read the data from.
        py_path is the python file that is created.
        """
        (preamble, strings) = read_po(po_path)
        write_py(py_path, strings)

    def rewrite_strings(pot_path, po_path):
        """Regenerate all string ids, which are stored as msgctxt in kodi .po files.

        pot_path is the .po or .pot file to read the 'master' data from.
        po_path is the .po file that is created.
        translations (msgstrs) are kept. Order is kept, but msgctxt will be renumbered.
        msgids missing from the .pot file are deleted from the .po file.
        """
        (potpreamble, potstrings) = read_po(pot_path)
        # renum pot file
        newsid = 30000
        renumpotstrings = []
        for (sid, msgid, msgstr) in potstrings:
            renumpotstrings.append((newsid, msgid, msgstr))
            if msgid != "":
                newsid += 1
        # renum and write po file
        (preamble, strings) = read_po(po_path)
        renumpostrings = []
        for (potsid, potmsgid, potmsgstr) in renumpotstrings:
            found = False
            for (sid, msgid, msgstr) in strings:
                if msgid == potmsgid:
                    renumpostrings.append((potsid, msgid, msgstr))
                    found = True
            if not found:
                renumpostrings.append((potsid, potmsgid, potmsgstr))
        # Now renumpostrings is matching pot
        write_po(po_path, preamble, renumpostrings)

    def write_po(po_path, preamble, strings):
        """Write a .po file to po_path with preamble and strings."""
        with open(po_path, "wb") as f:
            f.write(preamble)
            for (sid, msgid, msgstr) in strings:
                if msgid == "":
                    continue
                f.write(u'msgctxt "#{0}"\n'.format(sid))
                f.write(u'msgid "{0}"\n'.format(msgid))
                f.write(u'msgstr "{0}"\n'.format(msgstr))
                f.write('\n')


    def write_py(py_path, strings):
        """Write a .py file with variables for all strings in strings."""
        with open(py_path, "wb") as f:
            f.write(DO_NOT_EDIT_WARNING)
            localvars = {}
            # sort by value
            for (sid, msgid, msgstr) in strings:
                # Skip over first, empty string
                if msgid == "":
                    continue
                f.write(u'\n# "{0}"\n'.format(msgid))
                localvar = make_new_var(localvars, msgid, sid)
                localvars[localvar] = sid
                f.write(u"{0} = {1}\n".format(localvar, sid))


    def make_new_var(localvars, msgid, sid):
        """Make a local variable name from string msgid. Try to make the varnames readable."""
        localvar = msgid.lower()
        # replacement for %s and friends
        localvar = re.sub("%", "P", localvar)
        localvar = re.sub("[{}]", "I", localvar)
        localvar = re.sub('\\\\"', "Q", localvar)
        localvar = re.sub("\\\\", "B", localvar)
        # Remove other punctuation
        localvar = re.sub("[" + string.punctuation + "]", "", localvar)
        # beware of empty variable names
        if localvar == "":
            localvar = "_"
        # ensure valid varname
        localvar = re.sub("[^a-zA-Z0-9_]", "_", localvar)
        localvar = re.sub("^([0-9])", "N\\1", localvar)
        # No multiple _
        localvar = re.sub("_+", "_", localvar)
        # reduce number of words
        nrseps = localvar.count('_')
        if nrseps > 6:
            localvar = localvar[:find_nth(localvar, '_', 7) + 1]
        # Last resort: make unique and legal by appending sid, if necessary
        if localvar in localvars or keyword.iskeyword(localvar):
            localvar += "_" + str(sid)
            print("non-unique var: {0}".format(localvar))
        if len(localvar) > 50:
            print("long var: {0}".format(localvar))
        return localvar


    def read_po(po_path):
        strings = []
        sid = None
        msgid = None
        msgstr = None
        in_preamble = True
        preamble = ""
        with open(po_path, "r", encoding="utf-8") as l:
            for line in l.readlines():
                match = re.match("\s*msgctxt\s*\"(.*)\"", line)
                if match:
                    ctxt = match.group(1)
                    sid = int(ctxt[1:])
                    in_preamble = False

                match = re.match("\s*msgid\s*\"(.*)\"", line)
                if match:
                    msgid = match.group(1)
                    if msgid != "":
                        in_preamble = False

                if in_preamble:
                    preamble += line

                match = re.match("\s*msgstr\s*\"(.*)\"", line)
                if match:
                    msgstr = match.group(1)
                    strings.append((sid, msgid, msgstr))
                    sid = None
                    msgid = None
                    msgstr = None
        return (preamble, strings)

    def write_strings_module(stringsfile, *args):
        with open(stringsfile, "w") as f:
            f.write(DO_NOT_EDIT_WARNING)
            f.write(IMPORT_STAR_IS_BAD)
            for strings_module in args:
                f.write(u"from {0} import *\n".format(strings_module))



    KODI_STRINGS = "kodi_strings"
    LOCAL_STRINGS = "local_strings"
    STRINGS = "strings"
    # Main
    if len(sys.argv) == 4:

        kpo = sys.argv[1]
        init_strings(kpo, KODI_STRINGS + ".py")
        pot = sys.argv[2]
        ldir = sys.argv[3]
        for subdir in os.listdir(ldir):
            rewrite_strings(pot, os.path.join(ldir, subdir, "strings.po"))
        init_strings(pot, LOCAL_STRINGS + ".py")
        write_strings_module(STRINGS + ".py", KODI_STRINGS, LOCAL_STRINGS)
    else:
        print("""SYNTAX: """ + sys.argv[0] + """ [kodi_resource_path]
    where kodi resource path is a directory with standard kodi resources, e.g.
        %USERPROFILE%\\AppData\\Local\\Packages\\XBMCFoundation.Kodi_4n2hpmxwrvr6p\\LocalCache\\Roaming\\Kodi\\addons\\resource.language.nl_nl\\resources
    
    If you specify a kodi resource path, kodi_strings.py will be generated 
    as well for standard strings.
    If you don't specify it, only strings.py will be generated for 
    local strings.
    """)
        exit(1)

    # some tests
    if DO_TEST:
        import kodi_strings
        import local_strings

        for local_key in local_strings.__dict__.keys():
            if local_key.startswith("__") and local_key.endswith("__"):
                continue
            if local_key in kodi_strings.__dict__:
                print("WARNING: this string already exists in kodi standard strings, maybe remove:")
                print(local_key)

        # standing for both addon object and xbmc module
        class NamedStub(object):
            def __init__(self, name):
                self.name = name

            def getLocalizedString(self, sid):
                return "{0}.getLocalizedString({1})".format(self.name, sid)

            def log(self, s):
                print(s)
        import strings

        language = Po(NamedStub("addon"), NamedStub("xbmc"))
        try:
            print(language.get_string(strings.supercalifragilistic))
        except AttributeError as e:
            print(e)
        print(language.get_string(strings.new))
        print(language.get_string(strings.duration))
        print(language.get_string(strings.saturday))